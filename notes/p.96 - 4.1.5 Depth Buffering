In order for Direct3D to determine which pixels of an object 
are in front of another, it uses a technique called depth buffering or
z-buffering. Let us emphasize that with depth buffering, the order in which
we draw the objects does not matter.

(...) First, before any rendering takes place, the back buffer is cleared
to a default colour (like black or white), and the depth buffer is cleared
to a default value-usually 1.0 (the farthest depth value a pixel can have).
Now, suppose that the objects are rendered in the order of cylinder,
sphere and cone. The following table summarizes how the pixel P and its
corresponding depth value d are updated as the objects are drawn;
a similar process happens for te other pixels.

Figure 4.3 The view window corresponds to the 2D image (back buffer)
we generate of the 3D scene. We see that three different pixels can be
projected to the pixel P. Intuition tells us that P1 should be written 
to P because it is closer to the viewer and blocks the other two pixels.
The depth buffer algorithm provides a mechanical procedure for determining this
on a computer. Note that we show the depth values relative to the 3D scene
being viewed, but they are actually normalized to the range [0.0, 1.0] when 
stored in the depth buffer.

(...) The depth buffer is a texture, so it must be created with certain data 
formats. The formats used for depth buffering are as follows:

1. DXGI_FORMAT_D32_FLOAT_S8X24_UINT
2. DXGI_FORMAT_D32_FLOAT
3. DXGI_FORMAT_D24_UNORM_S8_UINT
4. DXGI_FORMAT_D16_UNORM


Note: An application is not required to have a stencil buffer, but if it does, 
the stencil buffer is always attached to the depth buffer. For example, 
the 32-bit format
DXGI_FORMAT_D24_UNORM_S8_UINT
uses 24-bits for the depth buffer and 8-bits for the stencil buffer.
For this reason, the depth buffer is better called the depth/stencil buffer.
Using the stencil buffer is a more advanced topic and will be explained 
in Chapter 10.


